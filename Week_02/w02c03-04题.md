
JDK version: 11
测试环境：
* 使用 `-Xlog:gc*:xxx.log` 输出 GC 日志到文件
* -Xmx 和 -Xms 相同，单位为 MB
* 使用 `-XX:-UseAdaptiveSizePolicy` 关闭自调整
* 测试 GCLogAnalysis 程序

测试结果：

单位：生成对象次数
| GC Strategy | 128 | 256  | 512   | 1024  | 2048  | 4096  |
| ----------- | --- | ---- | ----- | ----- | ----- | ----- |
| serial      | OOM | 5056 | 10536 | 13282 | 12712 | 10268 |
| par         | OOM | 4645 | 11552 | 17588 | 19439 | 15744 |
| cms         | OOM | 4982 | 11569 | 14007 | 14396 | 13693 |
| g1          | OOM | OOM  | 14407 | 18994 | 17722 | 17428 |



分析：
* 当内存太小时，会出现 OOM。这是因为堆内存中，可达对象太多，就算 full GC 也无法释放足够的内存
* 当内存很小时，CMS 策略的效果比 Parallel 好，因为 CMS 把 STW 的过程精简了
* 随着堆内存增大到 512 MB 和 1024 MB，G1 策略的性能是四种策略中最好的，因为它限制了垃圾回收的时间，把时间尽量用在业务中，这增加了吞吐量
* 但是随着堆内存增大到 4096 MB，系统吞吐量有所下降，这是因为堆内存过大，每次垃圾回收的 STW 时间加长了，反而不利于吞吐量

结论：
* 堆内存不能太大，小步快跑才是王道
* 堆内存多大才好？要通过压测才能找到



